class Game {

    // Board is [rows][cols]
    static Array board;
    static int boardCols;
    static int boardRows;

    static int nextShape;
    static int countdown;
    static int previousKey;

    static Cursor trialCursor;
    static Cursor cursor;

    static int EMPTY;
    static int COMPLETE;
    static int NON_EMPTY;

    static int GAME_OVER;
    static int RUNNING;
    static int gameState;

    function void init() {
        var bool stateChanged;

        do Cursor.init();

        let trialCursor = Cursor.new(0, 0, 0, 0);
        let cursor = Cursor.new(0, 0, 0, 0);

        let boardRows = 20;
        let boardCols = 10;

        let previousKey = 0;

        let EMPTY = 0;
        let COMPLETE = 1;
        let NON_EMPTY = 2;

        let GAME_OVER = 3;
        let RUNNING = 4;
        let gameState = RUNNING;

        let board = Game.createBoard(boardRows, boardCols);

        while(true){
            if(gameState = RUNNING){
                let stateChanged = Game.update();
                if(stateChanged){
                    do Screen.clearScreen();
                    do Game.render();
                }
            } else {
                if(gameState = GAME_OVER){
                    do Output.moveCursor(10, 10);
                    do Output.printString("Game over");
                    do Sys.halt();
                }
            }
        }
        return;
    }

    function bool update(){
        var int key, dx, dy, dr, newRotation, possibleRotations;
        var bool stateChanged;

        let key = Keyboard.keyPressed();
        if(~(key = previousKey)){
            let previousKey = key;

            let dx = 0;
            let dr = 0;

            if(key = 130){
                let dx = -1;
            }

            if(key = 132){
                let dx = 1;
            }

            if(key = 131){ // Up
                let dr = 1;
            }
        }

        if(countdown = 0){
            let dy = 1;
        } else {
            let dy = 0;
        }

        let stateChanged = false;

        if(~(dx=0) | ~(dr=0)){
            if(Game.isValidPosition(cursor, dx, 0, dr)){
                let stateChanged = true;
                do cursor.setX(cursor.getX() + dx);
                do cursor.rotate(dr);
            }
        }

        // Handle vertical movement last and alone - triggers new blocks
        if(~(dy=0)){
            if(Game.isValidPosition(cursor, 0, dy, 0)){
                let stateChanged = true;
                do cursor.setY(cursor.getY() + dy);
            } else {
                do Game.writeToBoard(cursor, board);

                // TODO: Randomize, start a new one properly
                do cursor.setY(0);
                if(~Game.isValidPosition(cursor, 0, 0, 0)){
                    let gameState = GAME_OVER;
                }
            }
        }

        if(countdown = 0){
            let countdown = 2000;
        } else {
            let countdown = countdown -1;
        }
        return stateChanged;
    }

    function void render(){
        do Game.renderBoard();
        do Game.renderShape(cursor, 0);
        return;
    }

    function void renderBoard(){
        var int i, j, row;

        let i = 0;
        while(i<boardRows){
            let j = 0;
            let row = board[i];
            while(j<boardCols){
                if(~(row[j] = 0)){
                    do Output.moveCursor(i, j);
                    do Output.printChar(0);
                }
                let j = j+1;
            }
            let i = i+1;
        }
        return;
    }

    function void renderShape(Cursor aCursor, char c){
        var int x, xOffset, cX,
                y, yOffset, cY,
                tile;
        var Array cTiles;

        let cX = cursor.getX();
        let cY = cursor.getY();
        let cTiles = cursor.getTiles();

        let yOffset = 0;
        let y = cY + yOffset;

        while(yOffset<4){
            let xOffset = 0;
            let x = cX + xOffset;
            while(xOffset<4){
                if((x>-1) & (x<boardCols) & (y>-1) & (y<boardRows)){
                    let tile = Matrix.get(cTiles, yOffset, xOffset);
                    if(~(tile = 0)){
                        do Output.moveCursor(y, x);
                        do Output.printChar(c);
                    }
                }
                let xOffset = xOffset+1;
                let x = cX + xOffset;
            }
            let yOffset = yOffset+1;
            let y = cY + yOffset;
        }
        return;
    }

    function Array createBoard(int rows, int columns){
        var Array board, row;
        var int i, j;

        let board = Array.new(rows);
        let i = 0;

        while(i<rows){
            let row = Array.new(columns);
            let board[i] = row;
            let j = 0;
            while(j<columns){
                let row[j] = 0;
                let j = j+1;
            }
            let i = i+1;
        }
        return board;
    }

    function int rowState(Array row, int columns){
        var int i, filledCount;

        let i = 0;
        let filledCount = 0;

        while(i<columns){
            if(~(row[i] = 0)){
                let filledCount = filledCount + 1;
            }
            let i = i+1;
        }

        if(filledCount = 0){
            return EMPTY;
        } else {
            if(filledCount = columns){
                return COMPLETE;
            } else {
                return NON_EMPTY;
            }
        }
    }

    function void removeCompleteLines(Array board, int rows){
        var int i, j, k;
        var Array ri, rk;

        let i = rows - 1;

        while(i>-1){
            let j = i + 1;
            let ri = board[i];

            if(j<rows){
                let board[j] = ri;
            } else {
                if(j=rows){
                    do ri.dispose();
                }
            }
            if(i=0){
                let rk = Array.new(boardCols);
                let board[i] = rk;
                let k = 0;
                while(k<boardCols){
                    let rk[k] = 0;
                    let k = k + 1;
                }
            }
            let i = i - 1;
        }
        return;
    }

    /**
     * Is the cursor position valid, optionally with an offset to
     * decide for candidate moves.
     *
     * A position is invalid if the tentronimo overlaps existing pieces
     * or is off the board.
     */
    function bool isValidPosition(Cursor aCursor, int dX, int dY, int dr){
        var int boardX, boardY, tileX, tileY, boardBaseX, boardBaseY, boardVal, tileVal;
        var Array cTiles;

        // Match cursor props.
        do trialCursor.setTetronimo(aCursor.getTetronimo());
        do trialCursor.setX(aCursor.getX());
        do trialCursor.setY(aCursor.getY());
        do trialCursor.setRotation(aCursor.getRotation());

        // Make the dx/dy/dr adjustments
        do trialCursor.setX(trialCursor.getX() + dX);
        do trialCursor.setY(trialCursor.getY() + dY);
        do trialCursor.rotate(dr);

        // Do the rest with the 'trial' cursor
        let boardBaseX = trialCursor.getX();
        let boardBaseY = trialCursor.getY();
        let cTiles = trialCursor.getTiles();

        let tileY = 0;
        while(tileY < 4){
            let tileX = 0;
            while(tileX < 4){
                let boardX = boardBaseX + tileX;
                let boardY = boardBaseY + tileY;

                let tileVal = Matrix.get(cTiles, tileY, tileX);
                if((boardX>-1) & (boardX<boardCols) & (boardY>-1) & (boardY<boardRows)){
                    let boardVal = Matrix.get(board, boardY, boardX);
                } else {
                    let boardVal = -1;
                }

                if((tileVal > 0) & (boardVal > 0)){
                    return false; // Overlapping cells
                }

                if((tileVal > 0) & (boardVal = -1)) {
                    return false; // Cells off-the board
                }
                let tileX = tileX + 1;
            }
            let tileY = tileY + 1;
        }
        return true;
    }

    function void writeToBoard(Cursor aCursor, Array aBoard){
        var int boardX, boardY, tileX, tileY, boardBaseX, boardBaseY, boardVal, tileVal;
        var Array cTiles;

        let boardBaseX = aCursor.getX();
        let boardBaseY = aCursor.getY();
        let cTiles = aCursor.getTiles();

        let tileY = 0;
        while(tileY < 4){
            let tileX = 0;
            while(tileX < 4){
                let boardX = boardBaseX + tileX;
                let boardY = boardBaseY + tileY;

                if((boardX>-1) & (boardX<boardCols) & (boardY>-1) & (boardY<boardRows)){
                    let tileVal = Matrix.get(cTiles, tileY, tileX);
                    if(tileVal > 0){  // Don't copy empty!
                        do Matrix.set(aBoard, boardY, boardX, tileVal);
                    }
                }
                let tileX = tileX + 1;
            }
            let tileY = tileY + 1;
        }
        return;
    }
}
