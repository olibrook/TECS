class Game {

    // Board is [rows][cols]
    static Array board;
    static int boardCols;
    static int boardRows;

    static int nextShape;
    static int countdown;
    static int previousKey;

    static Cursor cursor;

    static int EMPTY;
    static int COMPLETE;
    static int NON_EMPTY;

    function void init() {
        var bool stateChanged;

        do Cursor.init();

        let cursor = Cursor.new(0, 0, 0, 0);

        let boardRows = 20;
        let boardCols = 10;

        let previousKey = 0;

        let EMPTY = 0;
        let COMPLETE = 1;
        let NON_EMPTY = 2;

        let board = Game.createBoard(boardRows, boardCols);

        while(true){
            let stateChanged = Game.update();
            if(stateChanged){
                do Screen.clearScreen();
                do Game.render();
            }
        }
        return;
    }

    function bool update(){
        var int key, dx, dy, dr;
        var bool stateChanged;

        let key = Keyboard.keyPressed();
        if(~(key = previousKey)){
            let previousKey = key;

            let dx = 0;
            let dr = 0;

            if(key = 130){
                let dx = -1;
            }

            if(key = 132){
                let dx = 1;
            }

            if(key = 131){ // Up
                let dr = 1;
            }
        }

        if(countdown = 0){
            let dy = 1;
        } else {
            let dy = 0;
        }

        do Game.removeCompleteLines(board, boardRows);
        let stateChanged = Game.moveGameCursor(cursor, dx, dy);

        if(~(dr=0)){
            let stateChanged = stateChanged | Game.rotate(cursor, dr);
        }

        if(countdown = 0){
            let countdown = 1000;
        } else {
            let countdown = countdown -1;
        }

        return stateChanged;
    }

    function bool moveGameCursor(Cursor cursor, int dx, bool dy){
        var bool stateChanged;

        let stateChanged = false;

        // Vertical wraps
        if(~(dy=0)){
            if(Game.isValidMove(cursor, 0, dy)){
                let stateChanged = true;
                do cursor.setY(cursor.getY() + dy);
            }
        }

        // Horizontal clamps
        if(~(dx=0)){
            if(Game.isValidMove(cursor, dx, 0)){
                let stateChanged = true;
                do cursor.setX(cursor.getX() + dx);
            }
        }
        return stateChanged;
    }

    function void render(){
        do Game.renderBoard();
        do Game.renderShape(cursor, 0);
        return;
    }

    function void renderBoard(){
        var int i, j, row;

        let i = 0;
        while(i<boardRows){
            let j = 0;
            let row = board[i];
            while(j<boardCols){
                do Output.moveCursor(i, j);
                if(~(row[j] = 0)){
                    do Output.printChar(0);
                } else {
                    do Output.printChar(32);
                }
                let j = j+1;
            }
            let i = i+1;
        }
        return;
    }

    function void renderShape(Cursor aCursor, char c){
        var int x, xOffset, cX,
                y, yOffset, cY,
                tile;
        var Array cTiles;

        let cX = cursor.getX();
        let cY = cursor.getY();
        let cTiles = cursor.getTiles();

        let yOffset = 0;
        let y = cY + yOffset;

        while(yOffset<4){
            let xOffset = 0;
            let x = cX + xOffset;
            while(xOffset<4){
                if((x>-1) & (x<boardCols) & (y>-1) & (y<boardRows)){
                    let tile = Matrix.get(cTiles, yOffset, xOffset);
                    if(~(tile = 0)){
                        do Output.moveCursor(y, x);
                        do Output.printChar(c);
                    }
                }
                let xOffset = xOffset+1;
                let x = cX + xOffset;
            }
            let yOffset = yOffset+1;
            let y = cY + yOffset;
        }
        return;
    }

    function Array createBoard(int rows, int columns){
        var Array board, row;
        var int i, j;

        let board = Array.new(rows);
        let i = 0;

        while(i<rows){
            let row = Array.new(columns);
            let board[i] = row;
            let j = 0;
            while(j<columns){
                let row[j] = 0;
                let j = j+1;
            }
            let i = i+1;
        }
        return board;
    }

    function int randomInt(int start, int end){
        return 0;
    }

    function int rowState(Array row, int columns){
        var int i, filledCount;

        let i = 0;
        let filledCount = 0;

        while(i<columns){
            if(~(row[i] = 0)){
                let filledCount = filledCount + 1;
            }
            let i = i+1;
        }

        if(filledCount = 0){
            return EMPTY;
        } else {
            if(filledCount = columns){
                return COMPLETE;
            } else {
                return NON_EMPTY;
            }
        }
    }

    function void removeCompleteLines(Array board, int rows){
        var int i, j, k;
        var Array ri, rk;

        let i = rows - 1;

        while(i>-1){
            let j = i + 1;
            let ri = board[i];

            if(j<rows){
                let board[j] = ri;
            } else {
                if(j=rows){
                    do ri.dispose();
                }
            }
            if(i=0){
                let rk = Array.new(boardCols);
                let board[i] = rk;
                let k = 0;
                while(k<boardCols){
                    let rk[k] = 0;
                    let k = k + 1;
                }
            }
            let i = i - 1;
        }
        return;
    }

    function bool rotate(Cursor aCursor, int dr){
        var int newRotation, possibleRotations;

        let possibleRotations = 4;
        let newRotation = aCursor.getRotationIdx() + dr;
        let newRotation = (newRotation - ((newRotation/possibleRotations) * possibleRotations));
        do cursor.setRotationIdx(newRotation);
        return true;
    }

    /**
     * Is the cursor position valid, optionally with an offset to
     * decide for candidate moves.
     *
     * A position is invalid if the tentronimo overlaps existing pieces
     * or is off the board.
     */
    function bool isValidMove(Cursor aCursor, int dX, int dY){
        var int boardX, boardY, tileX, tileY, boardBaseX, boardBaseY, boardVal, tileVal;
        var Array cTiles;

        let boardBaseX = aCursor.getX() + dX;
        let boardBaseY = aCursor.getY() + dY;
        let cTiles = aCursor.getTiles();

        let tileY = 0;
        while(tileY < 4){
            let tileX = 0;
            while(tileX < 4){
                let boardX = boardBaseX + tileX;
                let boardY = boardBaseY + tileY;

                let tileVal = Matrix.get(cTiles, tileY, tileX);
                if((boardX>-1) & (boardX<boardCols) & (boardY>-1) & (boardY<boardRows)){
                    let boardVal = Matrix.get(board, boardY, boardX);
                } else {
                    let boardVal = -1;
                }

                if((tileVal > 0) & (boardVal > 0)){
                    return false; // Overlapping cells
                }

                if((tileVal > 0) & (boardVal = -1)) {
                    return false; // Cells off-the board
                }
                let tileX = tileX + 1;
            }
            let tileY = tileY + 1;
        }
        return true;
    }
}
