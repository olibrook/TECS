class Game {

    // Board is [rows][cols]
    static Array board;
    static int boardCols;
    static int boardRows;

    static int rowsComplete;

    static int countdown;
    static int previousKey;

    static Cursor trialCursor;
    static Cursor nextCursor;
    static Cursor cursor;

    static int GAME_OVER;
    static int RUNNING;
    static int gameState;

    function void init() {
        var bool stateChanged;

        // TODO: Set seed by counting cycles on title screen until input.
        do LCGRandom.setSeed(999);
        do Cursor.init();

        let trialCursor = Cursor.new(0, 0, 0, 0);
        let nextCursor = Game.randomizeCursor(Cursor.new(0, 0, 0, 0));
        let cursor = Game.randomizeCursor(Cursor.new(0, 0, 0, 0));

        let boardRows = 20;
        let boardCols = 10;

        let previousKey = 0;

        let GAME_OVER = 3;
        let RUNNING = 4;
        let gameState = RUNNING;

        let rowsComplete = 0;

        let board = Game.createBoard(boardRows, boardCols);

        while(true){
            if(gameState = RUNNING){
                let stateChanged = Game.update();
                if(stateChanged){
                    do Screen.clearScreen();
                    do Game.render();
                }
            } else {
                if(gameState = GAME_OVER){
                    do Output.moveCursor(10, 10);
                    do Output.printString("Game over");
                    do Sys.halt();
                }
            }
        }
        return;
    }

    function Cursor randomizeCursor(Cursor aCursor){
        do aCursor.setY(0);
        do aCursor.setX(0);
        do aCursor.setRotation(LCGRandom.randRange(0, 3));
        do aCursor.setTetronimo(LCGRandom.randRange(0, 6));
        return aCursor;
    }

    function bool update(){
        var int key, dx, dy, dr, newRotation, possibleRotations;
        var bool stateChanged;
        var Cursor temp;

        let key = Keyboard.keyPressed();
        if(~(key = previousKey)){
            let previousKey = key;

            let dx = 0;
            let dr = 0;

            if(key = 130){
                let dx = -1;
            }

            if(key = 132){
                let dx = 1;
            }

            if(key = 131){ // Up
                let dr = 1;
            }
        }

        if(countdown = 0){
            let dy = 1;
        } else {
            let dy = 0;
        }

        let stateChanged = false;

        if(~(dx=0) | ~(dr=0)){
            if(Game.isValidPosition(cursor, dx, 0, dr)){
                let stateChanged = true;
                do cursor.setX(cursor.getX() + dx);
                do cursor.rotate(dr);
            }
        }

        // Handle vertical movement last and alone - triggers new blocks
        if(~(dy=0)){
            if(Game.isValidPosition(cursor, 0, dy, 0)){
                let stateChanged = true;
                do cursor.setY(cursor.getY() + dy);

            } else {

                do Game.writeToBoard(cursor, board);
                do Game.removeCompleteLines();

                let temp = cursor;
                let cursor = nextCursor;
                let nextCursor = Game.randomizeCursor(temp);
                let temp = null;

                if(~Game.isValidPosition(cursor, 0, 0, 0)){
                    let gameState = GAME_OVER;
                }
            }
        }

        if(countdown = 0){
            let countdown = 4000;
        } else {
            let countdown = countdown -1;
        }
        return stateChanged;
    }

    function void render(){
        do Game.renderBoard();
        do Game.renderShape(cursor, 0);
        return;
    }

    function void renderBoard(){
        var int i, j, row;

        let i = 0;
        while(i<boardRows){
            let j = 0;
            let row = board[i];
            while(j<boardCols){
                if(~(row[j] = 0)){
                    do Output.moveCursor(i, j);
                    do Output.printChar(0);
                }
                let j = j+1;
            }
            let i = i+1;
        }
        return;
    }

    function void renderShape(Cursor aCursor, char c){
        var int x, xOffset, cX,
                y, yOffset, cY,
                tile;
        var Array cTiles;

        let cX = cursor.getX();
        let cY = cursor.getY();
        let cTiles = cursor.getTiles();

        let yOffset = 0;
        let y = cY + yOffset;

        while(yOffset<4){
            let xOffset = 0;
            let x = cX + xOffset;
            while(xOffset<4){
                if((x>-1) & (x<boardCols) & (y>-1) & (y<boardRows)){
                    let tile = Matrix.get(cTiles, yOffset, xOffset);
                    if(~(tile = 0)){
                        do Output.moveCursor(y, x);
                        do Output.printChar(c);
                    }
                }
                let xOffset = xOffset+1;
                let x = cX + xOffset;
            }
            let yOffset = yOffset+1;
            let y = cY + yOffset;
        }
        return;
    }

    function Array createBoard(int rows, int columns){
        var Array board, row;
        var int i, j;

        let board = Array.new(rows);
        let i = 0;

        while(i<rows){
            let row = Array.new(columns);
            let board[i] = row;
            let j = 0;
            while(j<columns){
                let row[j] = 0;
                let j = j+1;
            }
            let i = i+1;
        }
        return board;
    }

    function bool rowComplete(Array row){
        var int i, filledCount;

        let i = 0;
        let filledCount = 0;

        while(i<boardCols){
            if(row[i] > 0){
                let filledCount = filledCount + 1;
            }
            let i = i + 1;
        }
        return (filledCount = boardCols);
    }

    function void removeCompleteLines(){
        var int i, j, k;
        var Array newRow, oldRow;

        let i = boardRows - 1;

        while(i>-1){

            while(Game.rowComplete(board[i])){
                let rowsComplete = rowsComplete + 1;

                let oldRow = board[i];
                do oldRow.dispose();
                let board[i] = null;

                let j = i;
                while(j>-1){
                    if(j>0){
                        let board[j] = board[j-1];
                        let board[j-1] = null;

                    } else {
                        let newRow = Array.new(boardRows);
                        let k = 0;
                        while(k<boardRows){
                            let newRow[k] = 0;
                            let k = k+1;
                        }
                        let board[j] = newRow;
                    }
                    let j = j - 1;
                }
            }
            let i = i - 1;
        }
        return;
    }

    /**
     * Is the cursor position valid, optionally with an offset to
     * decide for candidate moves.
     *
     * A position is invalid if the tentronimo overlaps existing pieces
     * or is off the board.
     */
    function bool isValidPosition(Cursor aCursor, int dX, int dY, int dr){
        var int boardX, boardY, tileX, tileY, boardBaseX, boardBaseY, boardVal, tileVal;
        var Array cTiles;

        // Match cursor props.
        do trialCursor.setTetronimo(aCursor.getTetronimo());
        do trialCursor.setX(aCursor.getX());
        do trialCursor.setY(aCursor.getY());
        do trialCursor.setRotation(aCursor.getRotation());

        // Make the dx/dy/dr adjustments
        do trialCursor.setX(trialCursor.getX() + dX);
        do trialCursor.setY(trialCursor.getY() + dY);
        do trialCursor.rotate(dr);

        // Do the rest with the 'trial' cursor
        let boardBaseX = trialCursor.getX();
        let boardBaseY = trialCursor.getY();
        let cTiles = trialCursor.getTiles();

        let tileY = 0;
        while(tileY < 4){
            let tileX = 0;
            while(tileX < 4){
                let boardX = boardBaseX + tileX;
                let boardY = boardBaseY + tileY;

                let tileVal = Matrix.get(cTiles, tileY, tileX);
                if((boardX>-1) & (boardX<boardCols) & (boardY>-1) & (boardY<boardRows)){
                    let boardVal = Matrix.get(board, boardY, boardX);
                } else {
                    let boardVal = -1;
                }

                if((tileVal > 0) & (boardVal > 0)){
                    return false; // Overlapping cells
                }

                if((tileVal > 0) & (boardVal = -1)) {
                    return false; // Cells off-the board
                }
                let tileX = tileX + 1;
            }
            let tileY = tileY + 1;
        }
        return true;
    }

    function void writeToBoard(Cursor aCursor, Array aBoard){
        var int boardX, boardY, tileX, tileY, boardBaseX, boardBaseY, boardVal, tileVal;
        var Array cTiles;

        let boardBaseX = aCursor.getX();
        let boardBaseY = aCursor.getY();
        let cTiles = aCursor.getTiles();

        let tileY = 0;
        while(tileY < 4){
            let tileX = 0;
            while(tileX < 4){
                let boardX = boardBaseX + tileX;
                let boardY = boardBaseY + tileY;

                if((boardX>-1) & (boardX<boardCols) & (boardY>-1) & (boardY<boardRows)){
                    let tileVal = Matrix.get(cTiles, tileY, tileX);
                    if(tileVal > 0){  // Don't copy empty!
                        do Matrix.set(aBoard, boardY, boardX, tileVal);
                    }
                }
                let tileX = tileX + 1;
            }
            let tileY = tileY + 1;
        }
        return;
    }
}
